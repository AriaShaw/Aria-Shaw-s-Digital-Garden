metadata:
  title: 'Custom Module Development Development in Odoo Framework: Complete 2025 Guide'
  description: Comprehensive guide for Custom Module Development development using
    Odoo Framework and Python. Includes setup, best practices, code examples, testing,
    and deployment strategies.
  intent_type: researcher
  page_slug: odoo-17-inventory-module
  draft_metadata:
    created_by: pseo-bulk-generator
    template_id: development
    generation_mode: template
    confidence_level: high
static_data:
  development_subject: Custom Module Development
  module_name: my_module
  module_category: Technical
  module_version: '1.0'
  odoo_version: '17'
  python_version: '3.11'
  postgresql_version: '15'
  development_environment_setup: Setting up a development environment for Custom Module
    Development requires installing Odoo 17, Python 3.11, and PostgreSQL 15. Configure
    your IDE with code completion, debugging tools, and version control integration
    to maximize productivity.
  model_development_details: Develop Odoo models by creating Python classes that inherit
    from models.Model. Define fields using Odoo's field types (Char, Integer, Many2one,
    etc.), implement business logic in methods, and use @api decorators for compute
    fields and constraints. Follow Odoo's ORM conventions for database operations.
  view_development_details: Create XML views to define user interfaces for your models.
    Implement form views for data entry, tree views for listings, search views for
    filtering, and kanban views for visual organization. Use QWeb templates for custom
    rendering and maintain proper view inheritance hierarchies.
  business_logic_implementation: Implement business logic through model methods, computed
    fields, and workflow automation. Use @api.depends for field dependencies, @api.constrains
    for validation, and override standard methods (create, write, unlink) to add custom
    behavior. Keep logic modular and testable.
  security_implementation: Implement security through access rights (ir.model.access.csv)
    and record rules (XML). Define security groups, set CRUD permissions for each
    model, and create record-level rules to restrict data access. Test security thoroughly
    to prevent unauthorized access.
  testing_guidelines: Write unit tests using Odoo's TestCase framework. Test model
    methods, view rendering, and business logic with various scenarios. Use setUp/tearDown
    for test isolation, create test data with proper dependencies, and aim for 80%+
    code coverage. Run tests before committing changes.
  deployment_best_practices: Deploy custom_module module following Odoo best practices.
    Test in staging environment first, create database backups before deployment,
    use --update module_name for upgrades, and monitor logs for errors. Document deployment
    steps and maintain version control for rollback capability.
  module_structure_explanation: 'Organize your custom_module module with standard
    Odoo structure: __init__.py and __manifest__.py in root, models/ folder for Python
    models, views/ folder for XML views, security/ folder for access rights, data/
    folder for seed data, and static/ folder for assets. Follow naming conventions
    strictly.'
  development_type: Custom Module Development
  framework: Odoo Framework
  language: Python
  development_environment:
    required_tools:
    - tool: VS Code
      version: Latest
      purpose: Code editing and debugging
    - tool: Python 3.10+
      version: 3.10+
      purpose: Programming language runtime
    - tool: Git
      version: 2.40+
      purpose: Version control
    setup_commands:
    - '# Install development dependencies'
    - pip install -r requirements-dev.txt
    - npm install --save-dev eslint, prettier
    - '# Configure IDE'
    - code --install-extension ms-python.python
  project_structure:
    root_directory: my_odoo_project/
    structure: 'my_odoo_project/

      ├── my_module/

      │   ├── __init__.py

      │   ├── models/

      │   │   ├── __init__.py

      │   │   └── models.py

      │   ├── views/

      │   │   └── views.xml

      │   ├── controllers/

      │   │   └── main.py

      │   └── static/

      │       ├── src/

      │       │   ├── js/

      │       │   └── scss/

      │       └── description/

      ├── tests/

      │   └── test_my_module.py

      ├── __manifest__.py

      └── README.md

      '
  development_workflow:
  - step: 1
    title: Create Module Structure
    commands:
    - mkdir -p my_module/{models,views,controllers,static}
    - touch my_module/__init__.py
    - touch my_module/__manifest__.py
  - step: 2
    title: Define Data Models
    code_example: "from odoo import models, fields, api\n\nclass MyModel(models.Model):\n\
      \    _name = 'my_module.my_model'\n    _description = 'My Model Description'\n\
      \n    name = fields.Char(string='Name', required=True)\n    field_name = fields.Char(string='Field\
      \ Label')\n\n    @api.depends('dependency')\n    def _compute_computed_field(self):\n\
      \        for record in self:\n            record.computed_field = computation\
      \ logic\n"
  - step: 3
    title: Create Views
    xml_example: "<odoo>\n  <data>\n    <record id=\"view_my_model_form\" model=\"\
      ir.ui.view\">\n      <field name=\"name\">my_module.my_model.form</field>\n\
      \      <field name=\"model\">my_module.my_model</field>\n      <field name=\"\
      arch\" type=\"xml\">\n        <form string=\"Form Title\">\n          <sheet>\n\
      \            <group>\n              <field name=\"name\"/>\n              <field\
      \ name=\"field_name\"/>\n            </group>\n          </sheet>\n        </form>\n\
      \      </field>\n    </record>\n  </data>\n</odoo>\n"
  - step: 4
    title: Implement Business Logic
    business_logic: "@api.model\ndef create(self, vals):\n    # Custom creation logic\n\
      \    if 'validation_field' in vals:\n        self._validate_custom_field(vals['validation_field'])\n\
      \    return super().create(vals)\n"
  - step: 5
    title: Write Tests
    test_example: "from odoo.tests import TransactionCase\n\nclass TestCustomModule(TransactionCase):\n\
      \    def setUp(self):\n        super().setUp()\n        self.my_model = self.env['my_module.my_model']\n\
      \n    def test_feature(self):\n        # Test feature functionality\n      \
      \  record = self.my_model.create({\n            'name': 'Test Record',\n   \
      \         'custom_field': test_value\n        })\n        self.assertEqual(record.computed_field,\
      \ expected_value)\n"
  best_practices:
  - practice: Follow PEP 8 style guide
    implementation: Use flake8 or black for code formatting
  - practice: Write comprehensive tests
    coverage_target: 80% minimum code coverage
  - practice: Use meaningful variable names
    example: customer_invoice instead of ci
  - practice: Document your code
    tools: Sphinx for API documentation
  debugging_techniques:
  - technique: Odoo Shell
    command: python odoo-bin shell -d odoo_db
    use_case: Interactive debugging and data inspection
  - technique: Debug Mode
    activation: Add ?debug=1 to URL or use debug menu
    use_case: Frontend debugging and field inspection
  - technique: Logging
    code: '_logger.info(''Debug message: %s'', variable)'
    use_case: Track execution flow and variable values
  deployment_checklist:
  - 'Run all tests: python -m pytest tests/'
  - 'Check code quality: flake8 my_module'
  - Update version in __manifest__.py
  - Generate migration scripts if needed
  - Update documentation
  - Create git tag for release
  estimated_time: 1-2 weeks for basic module
  complexity_level: Intermediate to Advanced
ai_generated_content:
  introduction: 'Custom Odoo 17 modules that perform adequately during development
    testing with fifty records frequently collapse when production databases contain
    fifty thousand records and twenty concurrent users execute queries simultaneously.
    The development patterns in this guide prioritize production scalability from
    initial design—implementing efficient ORM queries that leverage PostgreSQL indexes,
    minimizing computed field calculations, using recordset operations that batch
    database access, and avoiding the N+1 query patterns that plague modules written
    by developers unfamiliar with Odoo''s lazy evaluation semantics.

    '
  main_content: "Developing Custom Module Development for Odoo 17 requires understanding\
    \ the framework's architectural patterns, ORM conventions, and view inheritance\
    \ system before writing code that integrates cleanly with core modules and survives\
    \ version upgrades without requiring complete rewrites.\n\nOdoo's development\
    \ paradigm differs fundamentally from traditional web frameworks. Rather than\
    \ building monolithic applications, you create modular addons that extend base\
    \ functionality through inheritance and composition. This modular architecture\
    \ enables selective feature activation but demands careful attention to module\
    \ dependencies and load order—incorrect dependency specification causes cryptic\
    \ import errors and runtime failures that waste hours of debugging.\n\n## Development\
    \ Environment Setup\n\nSetting up a development environment for Custom Module\
    \ Development requires installing Odoo 17, Python 3.11, and PostgreSQL 15. Configure\
    \ your IDE with code completion, debugging tools, and version control integration\
    \ to maximize productivity.\n\nThe development environment requires specific component\
    \ versions that match production deployment targets. Install Python 3.11, PostgreSQL\
    \ 15, and Node.js for asset compilation. Create isolated virtual environments\
    \ for each Odoo version—mixing dependencies across versions generates package\
    \ conflicts that break both environments.\n\nClone Odoo's source repository and\
    \ checkout the 17 branch. Install Python dependencies from requirements.txt, then\
    \ install the Odoo package in development mode using `pip install -e .` enabling\
    \ code changes without reinstallation.\n\nConfigure odoo.conf with development-friendly\
    \ settings: `--dev=all` enables auto-reload on code changes, detailed error traces,\
    \ and asset source maps. Set `--log-level=debug` for verbose logging and `--db-filter=dev_.*`\
    \ to prevent accidentally modifying production databases during development sessions.\n\
    \n## Module Structure and Manifest\n\nOrganize your custom_module module with\
    \ standard Odoo structure: __init__.py and __manifest__.py in root, models/ folder\
    \ for Python models, views/ folder for XML views, security/ folder for access\
    \ rights, data/ folder for seed data, and static/ folder for assets. Follow naming\
    \ conventions strictly.\n\nThe module manifest (__manifest__.py) declares dependencies,\
    \ data files, and module metadata. Incorrect dependency specification creates\
    \ subtle bugs—missing dependencies cause ImportError at runtime, circular dependencies\
    \ prevent module loading entirely, and extra dependencies slow module installation\
    \ unnecessarily.\n\n```python\n{\n    'name': '{module_name}',\n    'version':\
    \ '{module_version}',\n    'category': '{module_category}',\n    'depends': ['base',\
    \ 'sale', 'stock'],  # Critical: list ALL dependencies\n    'data': [\n      \
    \  'security/ir.model.access.csv',\n        'views/custom_views.xml',\n      \
    \  'data/demo_data.xml',\n    ],\n    'installable': True,\n    'application':\
    \ False,\n    'auto_install': False,\n}\n```\n\nData files load sequentially during\
    \ module installation. Order matters critically—security definitions must load\
    \ before views that reference secured models, views must exist before menu items\
    \ that display them. Incorrect ordering causes installation failures requiring\
    \ database restoration.\n\n## Model Development and ORM Usage\n\nDevelop Odoo\
    \ models by creating Python classes that inherit from models.Model. Define fields\
    \ using Odoo's field types (Char, Integer, Many2one, etc.), implement business\
    \ logic in methods, and use @api decorators for compute fields and constraints.\
    \ Follow Odoo's ORM conventions for database operations.\n\nOdoo models inherit\
    \ from `models.Model` or `models.TransientModel` depending on persistence requirements.\
    \ Regular models store data permanently in PostgreSQL tables. Transient models\
    \ exist temporarily in memory for wizards and temporary calculations—think of\
    \ them as session storage that expires after user interactions complete.\n\nModel\
    \ field definitions specify database column types, widget rendering, and validation\
    \ rules. Field types (Char, Text, Integer, Float, Boolean, Date, Datetime, Selection,\
    \ Many2one, One2many, Many2many) map to PostgreSQL column types with additional\
    \ metadata for UI rendering.\n\n```python\nclass CustomModel(models.Model):\n\
    \    _name = 'custom.model'\n    _description = 'Custom Model Description'\n\n\
    \    name = fields.Char(string='Name', required=True, index=True)\n    description\
    \ = fields.Text(string='Description')\n    state = fields.Selection([\n      \
    \  ('draft', 'Draft'),\n        ('confirmed', 'Confirmed'),\n        ('done',\
    \ 'Done'),\n    ], default='draft', string='Status')\n    partner_id = fields.Many2one('res.partner',\
    \ string='Customer')\n    line_ids = fields.One2many('custom.model.line', 'parent_id',\
    \ string='Lines')\n```\n\nThe ORM provides abstraction over raw SQL but introduces\
    \ performance implications when used incorrectly. The infamous N+1 query problem\
    \ emerges when iterating records without prefetching related data—each loop iteration\
    \ triggers separate database queries that could be consolidated through proper\
    \ prefetch configuration.\n\n## View Development and Inheritance\n\nCreate XML\
    \ views to define user interfaces for your models. Implement form views for data\
    \ entry, tree views for listings, search views for filtering, and kanban views\
    \ for visual organization. Use QWeb templates for custom rendering and maintain\
    \ proper view inheritance hierarchies.\n\nOdoo views define UI rendering for models.\
    \ Form views display individual records, tree views show lists, search views filter\
    \ datasets, kanban views present cards, and pivot/graph views aggregate data visually.\
    \ Each view type has specific XML structure and widget requirements.\n\nView inheritance\
    \ enables modification of existing views without editing core files—critical for\
    \ maintaining upgrade compatibility. Inheritance uses XPath expressions to locate\
    \ elements, then applies modifications (adding fields, removing elements, changing\
    \ attributes).\n\n```xml\n<record id=\"view_custom_form\" model=\"ir.ui.view\"\
    >\n    <field name=\"name\">custom.model.form</field>\n    <field name=\"model\"\
    >custom.model</field>\n    <field name=\"arch\" type=\"xml\">\n        <form string=\"\
    Custom Model\">\n            <sheet>\n                <group>\n              \
    \      <field name=\"name\"/>\n                    <field name=\"description\"\
    />\n                    <field name=\"state\"/>\n                </group>\n  \
    \              <notebook>\n                    <page string=\"Lines\">\n     \
    \                   <field name=\"line_ids\">\n                            <tree\
    \ editable=\"bottom\">\n                                <field name=\"product_id\"\
    />\n                                <field name=\"quantity\"/>\n             \
    \               </tree>\n                        </field>\n                  \
    \  </page>\n                </notebook>\n            </sheet>\n        </form>\n\
    \    </field>\n</record>\n```\n\nView inheritance for existing views requires\
    \ precise XPath selection. Add fields after specific elements using `<field name=\"\
    new_field\" position=\"after\"/>`. Replace elements entirely with `position=\"\
    replace\"`. Hide fields through `invisible=\"1\"` attributes rather than removing\
    \ them—removal breaks functionality in other modules that reference those fields.\n\
    \n## Business Logic and Computed Fields\n\nImplement business logic through model\
    \ methods, computed fields, and workflow automation. Use @api.depends for field\
    \ dependencies, @api.constrains for validation, and override standard methods\
    \ (create, write, unlink) to add custom behavior. Keep logic modular and testable.\n\
    \nBusiness logic implementation occurs in model methods decorated with framework-specific\
    \ decorators. `@api.depends()` declares field dependencies for computed fields.\
    \ `@api.constrains()` validates data before database commits. `@api.onchange()`\
    \ updates form values dynamically as users type.\n\nComputed fields calculate\
    \ values from other fields rather than storing data directly. Use computed fields\
    \ for derived values that change when source data changes—don't store computed\
    \ values redundantly creating data synchronization problems.\n\n```python\n@api.depends('line_ids.subtotal')\n\
    def _compute_total(self):\n    for record in self:\n        record.total = sum(record.line_ids.mapped('subtotal'))\n\
    \n@api.constrains('quantity')\ndef _check_quantity(self):\n    for record in self:\n\
    \        if record.quantity <= 0:\n            raise ValidationError('Quantity\
    \ must be positive')\n\n@api.onchange('partner_id')\ndef _onchange_partner(self):\n\
    \    if self.partner_id:\n        self.payment_term_id = self.partner_id.property_payment_term_id\n\
    ```\n\nThe decorator stack executes in specific order. `@api.depends` recalculates\
    \ whenever dependencies change. `@api.constrains` validates before database write.\
    \ `@api.onchange` updates UI immediately during data entry without database round-trips.\n\
    \n## Security and Access Rights\n\nImplement security through access rights (ir.model.access.csv)\
    \ and record rules (XML). Define security groups, set CRUD permissions for each\
    \ model, and create record-level rules to restrict data access. Test security\
    \ thoroughly to prevent unauthorized access.\n\nSecurity operates through two\
    \ layers: model-level access rights (ir.model.access) and record-level rules (ir.rule).\
    \ Access rights control which groups can create, read, update, or delete records\
    \ globally. Record rules filter datasets based on domain expressions—users only\
    \ see records matching rule conditions.\n\n```csv\nid,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink\n\
    access_custom_model_user,custom.model.user,model_custom_model,base.group_user,1,1,1,0\n\
    access_custom_model_manager,custom.model.manager,model_custom_model,base.group_system,1,1,1,1\n\
    ```\n\nRecord rules use domain syntax to filter records. Restrict users to their\
    \ own records with `[('user_id', '=', user.id)]`. Filter by company for multi-company\
    \ setups with `[('company_id', 'in', company_ids)]`. Combine multiple conditions\
    \ using boolean operators.\n\nSecurity holes emerge from incomplete coverage.\
    \ Grant access rights for ALL models your module creates. Define record rules\
    \ for scenarios requiring data isolation. Test security thoroughly—login as non-admin\
    \ users and verify they cannot access restricted records.\n\n## Testing and Quality\
    \ Assurance\n\nWrite unit tests using Odoo's TestCase framework. Test model methods,\
    \ view rendering, and business logic with various scenarios. Use setUp/tearDown\
    \ for test isolation, create test data with proper dependencies, and aim for 80%+\
    \ code coverage. Run tests before committing changes.\n\nOdoo provides unit testing\
    \ framework based on Python's unittest. Tests run against temporary databases\
    \ created and destroyed per test class—modifications don't affect development\
    \ data.\n\n```python\nfrom odoo.tests import TransactionCase\n\nclass TestCustomModel(TransactionCase):\n\
    \    def setUp(self):\n        super().setUp()\n        self.model = self.env['custom.model']\n\
    \        \n    def test_create_record(self):\n        record = self.model.create({'name':\
    \ 'Test'})\n        self.assertTrue(record.exists())\n        self.assertEqual(record.state,\
    \ 'draft')\n```\n\nTest critical workflows end-to-end: create records, transition\
    \ states, compute totals, generate reports. Don't just test happy paths—verify\
    \ error handling for invalid data, missing required fields, and constraint violations.\n\
    \nRun tests locally before committing code: `odoo-bin -c odoo.conf -d test_db\
    \ --test-enable --stop-after-init`. Fix failing tests immediately—don't commit\
    \ broken tests intending to fix later. Broken tests compound into massive cleanup\
    \ efforts that block development for days.\n\n## Deployment and Version Control\n\
    \nDeploy custom_module module following Odoo best practices. Test in staging environment\
    \ first, create database backups before deployment, use --update module_name for\
    \ upgrades, and monitor logs for errors. Document deployment steps and maintain\
    \ version control for rollback capability.\n\nUse git for version control with\
    \ branches matching Odoo versions: master for Odoo 18, 17.0 for Odoo 17. Tag releases\
    \ with semantic versioning: v1.0.0 for initial release, v1.1.0 for feature additions,\
    \ v1.0.1 for bug fixes.\n\nDeploy custom modules by copying to Odoo's addons path\
    \ or using `--addons-path` configuration. Restart Odoo service after file changes\
    \ in production. Update module through Odoo UI (Apps > Upgrade) to apply database\
    \ schema changes and reload views.\n\nMaintain separate development, staging,\
    \ and production environments. Test in development, validate in staging with production\
    \ data clones, then deploy to production during maintenance windows. Never develop\
    \ directly in production—production bugs affect real business operations and angry\
    \ users.\n"
  conclusion: 'Development documentation determines whether custom modules represent
    maintainable organizational assets or undocumented code that only original developers
    understand. The documentation you created—inline code comments explaining complex
    logic, architectural decision records describing why implementations chose specific
    approaches, and deployment procedures detailing installation and configuration
    requirements—enables knowledge transfer when team composition changes and provides
    troubleshooting reference when production issues require rapid diagnosis.


    Treat documentation as deliverable requiring same quality standards as code itself
    rather than optional afterthought that developers skip when timeline pressure
    increases. Schedule documentation writing as explicit development tasks with time
    estimates and quality review rather than expecting developers to document during
    spare time that never materializes. Incomplete documentation creates technical
    debt accumulating interest through troubleshooting delays, slow onboarding, and
    the recurring context-switching costs when only one person understands how modules
    function.


    Maintain documentation alongside code evolution rather than allowing drift where
    documentation describes functionality that no longer matches actual implementation
    after months of enhancement and bug fixes. Include documentation updates as acceptance
    criteria for all code changes—pull requests modifying module behavior should include
    corresponding documentation updates explaining changes. Version-controlled documentation
    preserves historical context explaining why implementations evolved specific directions—this
    history proves valuable when future developers question past decisions and consider
    reverting to earlier approaches that documentation reveals as already explored
    and rejected for documented reasons.



    Stay current with Odoo developments and best practices. Our monthly digest summarizes
    breaking changes, security updates, and community-contributed modules worth evaluating
    for production use.'
  extended_content: ''
conversion_assets:
- component_type: callout-box
  placement_hint: mid_guide
  generated_copy:
    headline: Server Sizing Calculator
    body: Development and troubleshooting utilities
    cta_text: Server Sizing Calculator
    cta_link: /downloads/server-sizing-calculator/
    cta_context: Priority 2.5 link from intelligent linking system
- component_type: callout-box
  placement_hint: post_technical
  generated_copy:
    headline: Network Troubleshooting Toolkit
    body: Development and troubleshooting utilities
    cta_text: Network Troubleshooting Toolkit
    cta_link: /downloads/network-troubleshooting-toolkit/
    cta_context: Priority 2.5 link from intelligent linking system
intelligent_links:
- link_url: /versus/odoo-14-accounting-module/
  anchor_text: 'Custom Module Development Development in Odoo Framework: Complete
    2025 Guide'
  context: Advanced customization options
  link_type: advanced_guide
  priority: 3.0
- link_url: /guides/odoo-api-key-management/
  anchor_text: 'API Development Development in Odoo Framework: Complete 2025 Guide'
  context: API documentation and reference
  link_type: api_reference
  priority: 4.0
- link_url: /guides/fix-odoo-500-internal-server-error/
  anchor_text: Troubleshooting Guide
  context: Common issues and solutions
  link_type: related_troubleshooting
  priority: 11
- link_url: /guides/odoo-100-users-server/
  anchor_text: 'Odoo 18 Server for 100 Users: Hardware & Architecture Guide'
  context: Advanced development patterns
  link_type: advanced_patterns
  priority: 5.5
visualizations:
- chart_type: mermaid
  placement_hint: after_guide
  data_context: development workflow visualization (semantic variant)
  mermaid_chart_syntax: "flowchart LR\n    Start([New Module]) --> Scaffold[Scaffold\
    \ Module Structure]\n    Scaffold --> Models[Define Models]\n    Models --> Views[Create\
    \ Views]\n    Views --> Security[Setup Security Rules]\n    Security --> Logic[Implement\
    \ Business Logic]\n    Logic --> Test[Write Unit Tests]\n    Test --> End([Module\
    \ Complete])\n\n    classDef dev fill:#9c27b0,stroke:#7b1fa2,stroke-width:2px,color:#fff\n\
    \    classDef structure fill:#2196f3,stroke:#1976d2,stroke-width:2px,color:#fff\n\
    \    classDef success fill:#d4edda,stroke:#28a745,stroke-width:2px\n\n    class\
    \ Scaffold,Models,Views,Security dev\n    class Logic,Test structure\n    class\
    \ Start,End success\n"
  variant_id: development_chart_001
- chart_type: mermaid
  placement_hint: after_prerequisites
  data_context: 'Phase 1: Module Structure Setup'
  mermaid_chart_syntax: "flowchart TB\n    Start([Module Init]) --> Manifest[Create\
    \ __manifest__.py]\n    Manifest --> Models[models/ Directory]\n    Models -->\
    \ Views[views/ Directory]\n    Views --> Security[security/ Directory]\n    Security\
    \ --> Data[data/ Directory]\n    Data --> Static[static/ Directory]\n    Static\
    \ --> End([Structure Ready])\n\n    classDef structure fill:#2196f3,stroke:#1976d2,stroke-width:2px,color:#fff\n\
    \    classDef files fill:#ff9800,stroke:#f57c00,stroke-width:2px,color:#fff\n\
    \    classDef success fill:#d4edda,stroke:#28a745,stroke-width:2px\n\n    class\
    \ Manifest,Models,Views structure\n    class Security,Data,Static files\n    class\
    \ Start,End success\n"
  variant_id: development_chart_001_structure
- chart_type: mermaid
  placement_hint: after_steps
  data_context: 'Phase 3: Testing & Quality'
  mermaid_chart_syntax: "flowchart LR\n    Start([Code Complete]) --> Unit[Write Unit\
    \ Tests]\n    Unit --> Integration[Integration Tests]\n    Integration --> Coverage[Check\
    \ Code Coverage]\n    Coverage --> Lint[Run Linters]\n    Lint --> Format[Code\
    \ Formatting]\n    Format --> Review[Code Review]\n    Review --> End([Quality\
    \ Assured])\n\n    classDef test fill:#4caf50,stroke:#388e3c,stroke-width:2px,color:#fff\n\
    \    classDef quality fill:#ff9800,stroke:#f57c00,stroke-width:2px,color:#fff\n\
    \    classDef success fill:#d4edda,stroke:#28a745,stroke-width:2px\n\n    class\
    \ Unit,Integration,Coverage test\n    class Lint,Format,Review quality\n    class\
    \ Start,End success\n"
  variant_id: development_chart_001_testing
- chart_type: mermaid
  placement_hint: after_conclusion
  data_context: learning path and knowledge graph
  mermaid_chart_syntax: "flowchart TB\n\n    Current[\"⬤ Custom Module Development\
    \ Development in Odoo Framework: Complete 2025 Guide\"]\n\n    %% Next Steps -\
    \ Learning Progression\n    Current --> Next0(\"Custom Module Development Development\
    \ in Odoo Framework: Complete 2025 Guide\")\n\n    %% Troubleshooting - Problem\
    \ Resolution\n    Current -.-> Trouble0[\"Troubleshooting Guide\"]\n\n    %% Professional\
    \ Styling\n    classDef current fill:#ffc107,stroke:#ff9800,stroke-width:3px,color:#000\n\
    \    classDef prereq fill:#e3f2fd,stroke:#1976d2,stroke-width:2px,color:#000\n\
    \    classDef next fill:#e8f5e9,stroke:#388e3c,stroke-width:2px,color:#000\n \
    \   classDef related fill:#f5f5f5,stroke:#616161,stroke-width:1px,color:#000\n\
    \    classDef trouble fill:#fff3e0,stroke:#f57c00,stroke-width:2px,color:#000\n\
    \    classDef support fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#000\n\
    \n    class Current current\n    class Next0 next\n    class Trouble0 trouble"
