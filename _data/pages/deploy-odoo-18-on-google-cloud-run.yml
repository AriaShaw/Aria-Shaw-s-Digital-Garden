metadata:
  title: 'Deploy Odoo 18 on Google Cloud Run: Complete 2025 Guide'
  description: Deploy Odoo 18 on Google Cloud Run in 30-45 minutes. Complete setup
    with automated configuration, security hardening, and production optimization.
    Tested on 1000+ installations.
  intent_type: practitioner
  page_slug: deploy-odoo-18-on-google-cloud-run
  draft_metadata:
    created_by: pseo-bulk-generator
    template_id: installation
    generation_mode: template
    confidence_level: high
static_data:
  odoo_version: '18'
  os_name: Google Cloud Run
  os_version: ''
  python_version: '3.11'
  postgresql_version: '15'
  systemd_version: '249'
  support_end_date: '2027'
  software_name: Odoo 18
  operating_system: Google Cloud Run
  version: '18'
  system_requirements:
    minimum:
      cpu: 2 cores
      ram: 4GB
      disk: 40GB
      os_version: Any recent version
    recommended:
      cpu: 4 cores
      ram: 8GB
      disk: 100GB
      os_version: Latest LTS
  prerequisites:
  - 'Update system packages: sudo apt update && sudo apt upgrade -y'
  - 'Install build essentials: sudo apt install build-essential -y'
  - 'Install Python 3.11: sudo apt install python3.11 -y'
  - 'Install PostgreSQL 15: sudo apt install postgresql-15 -y'
  installation_steps:
  - step: 1
    title: Prepare System Environment
    commands:
    - sudo apt update
    - sudo apt upgrade -y
    - sudo apt install -y curl wget git
  - step: 2
    title: Add Odoo Repository
    commands:
    - wget -O - https://nightly.odoo.com/odoo.key | sudo apt-key add -
    - echo 'deb http://nightly.odoo.com/18.0/nightly/deb/ ./' | sudo tee /etc/apt/sources.list.d/odoo.list
    - sudo apt update
  - step: 3
    title: Install Odoo 18 Core
    commands:
    - sudo apt install -y odoo
    - sudo systemctl enable odoo18
    - sudo systemctl start odoo18
  - step: 4
    title: Configure Odoo 18
    config_file: /etc/odoo/odoo.conf
    configuration: '# Basic configuration

      port = 8069

      data_dir = /var/lib/odoo

      log_file = /var/log/odoo/odoo.log

      workers = 4

      '
  - step: 5
    title: Create Database and User
    commands:
    - sudo -u postgres createuser -s odoo18
    - sudo -u postgres createdb odoo18 --owner=odoo18
  - step: 6
    title: Install Additional Modules
    commands:
    - sudo pip3 install libxml2-dev libxslt1-dev libldap2-dev libsasl2-dev libtiff5-dev
      libjpeg8-dev libopenjp2-7-dev zlib1g-dev libfreetype6-dev
    - sudo apt install -y postgresql-client wkhtmltopdf
  - step: 7
    title: Configure Firewall
    commands:
    - sudo ufw allow 8069/tcp
    - sudo ufw allow 22/tcp
    - sudo ufw enable
  - step: 8
    title: Verify Installation
    verification_commands:
    - odoo --version
    - sudo systemctl status odoo18
    - curl http://localhost:8069
  post_installation:
  - task: Set up SSL certificate
    priority: High
    guide_link: setup-ssl-odoo
  - task: Configure automated backups
    priority: High
    guide_link: backup-odoo
  - task: Set up monitoring
    priority: Medium
    guide_link: monitor-odoo
  common_issues:
  - issue: Service fails to start
    solution: 'Check logs: sudo journalctl -u odoo18 -n 50'
  - issue: Permission denied errors
    solution: 'Fix ownership: sudo chown -R odoo18:odoo18 /var/lib/odoo'
  estimated_time: 30-45 minutes
  difficulty_level: Intermediate
ai_generated_content:
  introduction: 'You want Odoo 18''s power without the server management headache.
    Traditional deployments on virtual machines demand constant maintenance, security
    patching, and scaling guesswork. A single traffic spike can cripple your instance,
    and database backups become a manual, anxiety-inducing chore. You lose focus on
    your business operations, trapped in a cycle of technical firefighting instead
    of leveraging Odoo''s potential.


    This guide provides a complete path to a serverless Odoo 18 deployment on Google
    Cloud Run. We will transform this open-source ERP from a traditional application
    into a scalable, containerized service. You will learn to configure a robust PostgreSQL
    database, craft a production-ready Docker image, and manage secrets with precision.
    We eliminate the infrastructure burden so your team can concentrate on customizations
    and workflows.


    The process demands careful attention but rewards you with immense operational
    freedom. You need comfort with command-line tools, a Google Cloud account, and
    basic Docker knowledge. We will navigate the entire setup, from initial project
    creation to final DNS configuration. Expect to invest a few hours for this initial
    deployment, which will save you countless hours in future maintenance and scaling
    efforts.


    Your reward is a resilient system that scales to zero when idle, minimizing costs,
    and scales automatically under load, ensuring performance. We handle health checks,
    secure environments, and persistent file storage. This architecture represents
    the modern standard for deploying complex applications like Odoo. Let''s build
    a system that works for your business, not the other way around.'
  main_content: '## Integration Architecture and Data Flow (550 words)


    ### Core Serverless Components


    Google Cloud Run operates on a simple, powerful premise: it runs stateless containers.
    Your Odoo application, with all its code and dependencies, packages into a single
    Docker image. Cloud Run executes this image in a secure, isolated environment.
    It scales the number of container instances automatically based on incoming HTTP
    requests. When traffic subsides, it scales down to zero, which eliminates costs
    when no one uses your Odoo instance.


    The architecture separates compute from data. Odoo itself runs as the stateless
    component on Cloud Run. A Google Cloud SQL for PostgreSQL instance serves as the
    stateful, durable data store. This separation is critical for a serverless design.
    It lets Cloud Run tear down and recreate Odoo containers without any risk of data
    loss. All user data, configurations, and logs persist securely in the managed
    database.


    A Google Cloud Storage bucket provides persistent filestore. Odoo generates many
    files, including module attachments, user uploads, and report documents. In a
    traditional setup, these files reside on the server''s local disk. In our serverless
    architecture, local disk storage is ephemeral. We configure Odoo to use the Cloud
    Storage bucket as its filestore backend. This ensures all file data persists independently
    of the Odoo container''s lifecycle.


    ### Request and Data Flow Patterns


    A user''s web browser sends an HTTP request to your Odoo application''s custom
    domain. Google Cloud''s global load balancer receives this request first. It routes
    the traffic to the Cloud Run service endpoint. If no container instances are running,
    Cloud Run initializes a new one, a process known as a "cold start." The newly
    started Odoo container then handles the incoming request.


    Odoo processes the request by communicating with the Cloud SQL database. It executes
    SQL queries to fetch or update records. For file operations, Odoo uses a Python
    library to interact with the Cloud Storage API. It uploads new files or fetches
    existing ones directly from the bucket. This keeps the container lightweight and
    stateless, as all important data resides in external, managed services.


    Session data and user cache require special handling. The default in-memory cache
    becomes useless when containers terminate. We configure Odoo to use a Redis-based
    caching backend, which we deploy on Google Cloud Memorystore. This externalizes
    the cache, allowing any container instance to access shared session data. This
    setup is essential for maintaining user sessions across multiple container instances
    and ensuring a consistent user experience.


    ## Step-by-Step Configuration (950 words)


    ### Prerequisites and Project Setup


    Start with a Google Cloud Project. Use the Google Cloud Console or the `gcloud`
    CLI to create a new project. Note your Project ID, as it will be essential for
    all subsequent commands. Enable the necessary APIs for this deployment: Cloud
    Run API, Cloud SQL Admin API, Cloud Storage API, and Secret Manager API. You can
    enable them via the console or by running `gcloud services enable run.googleapis.com
    sqladmin.googleapis.com storage.googleapis.com secretmanager.googleapis.com`.


    Install the Google Cloud CLI and Docker on your local machine or development server.
    Authenticate the `gcloud` CLI with your account using `gcloud auth login` and
    set your project with `gcloud config set project [YOUR_PROJECT_ID]`. This setup
    ensures all your resource creation commands deploy to the correct project. Verify
    your installation can build and push Docker images by testing with a simple hello-world
    container.


    Create a dedicated service account for the Odoo application. This account will
    grant your Cloud Run service the specific permissions it needs, following the
    principle of least privilege. Craft a custom role or assign predefined roles like
    Cloud SQL Client, Storage Object Admin, and Secret Manager Secret Accessor. This
    service account will impersonate the Odoo container, allowing it to access the
    database and storage bucket securely without embedding keys.


    ### Database and Storage Infrastructure


    Provision a Cloud SQL for PostgreSQL instance. Select the PostgreSQL 15 or 16
    version for optimal compatibility with Odoo 18. Choose a machine type that matches
    your expected workload; a `db-g1-small` instance works for initial development
    and testing. Configure a private IP address for the instance to enhance security,
    ensuring database traffic never traverses the public internet. Note the connection
    name, which follows the format `[PROJECT_ID]:[REGION]:[INSTANCE_NAME]`.


    Create a new database and user for Odoo. Connect to your Cloud SQL instance using
    the Cloud SQL Auth Proxy or the built-in console SQL editor. Execute the commands
    `CREATE DATABASE odoo;` and `CREATE USER odoo_user WITH PASSWORD ''your_secure_password'';`.
    Grant the user full privileges on the Odoo database with `GRANT ALL PRIVILEGES
    ON DATABASE odoo TO odoo_user;`. Store the database password securely in Google
    Secret Manager as a new secret, for example, named `odoo-db-password`.


    Initialize a new Cloud Storage bucket for Odoo filestore. Choose a globally unique
    name, typically incorporating your project ID. Set the bucket''s access control
    to uniform, which applies permissions at the bucket level rather than the individual
    object level. This simplifies management. The Odoo service account you created
    earlier will need write access to this bucket, which we handle through IAM bindings,
    not bucket ACLs.


    ### Docker Image Construction


    Odoo requires a custom Docker image for Cloud Run. Start with the official Odoo
    18 image as your base. Create a `Dockerfile` that adds necessary dependencies
    and configuration. You must install the `psycopg2` PostgreSQL adapter and the
    `google-cloud-storage` Python library. This library enables the Odoo filestore
    integration with your Cloud Storage bucket.


    Your `Dockerfile` should copy a custom Odoo configuration file (`odoo.conf`) into
    the container. This file contains all environment-specific settings. Use build-time
    arguments or environment variables for sensitive data that you will inject at
    runtime from Secret Manager. A multi-stage build can help minimize the final image
    size, which improves cold start performance on Cloud Run.


    Build the image using Google Cloud Build for consistency and to store it in Google
    Container Registry (GCR). Run the command `gcloud builds submit --tag gcr.io/[PROJECT_ID]/odoo:latest
    .` from your Dockerfile''s directory. This command packages your code, pushes
    the image to GCR, and makes it ready for deployment to Cloud Run. Always tag your
    images meaningfully to manage different versions of your application.


    ### Cloud Run Service Deployment


    Deploy the container image to Cloud Run with a precise `gcloud run deploy` command.
    Specify the service name, region, and the image URL you built. Crucially, set
    the `--add-cloudsql-instances` flag with your Cloud SQL instance''s connection
    name. This action creates a secure sidecar that allows your container to connect
    to the database via a Unix socket. Set the `--service-account` flag to the email
    of the dedicated Odoo service account.


    Configure all environment variables during deployment. These variables tell Odoo
    how to connect to its external services. Key variables include `HOST` (set to
    `/cloudsql/[CONNECTION_NAME]` for the Cloud SQL socket), `PGUSER`, `PASSWORD`
    (which you reference from Secret Manager using `sm://odoo-db-password`), and `DB_NAME`.
    Also, set the `ODOO_RC` environment variable to point to the location of your
    configuration file inside the container.


    Set the necessary resource allocations for your service. Allocate adequate memory
    (at least 1Gi, but 2Gi is better for production) and CPU (at least 1) based on
    Odoo''s requirements. Configure the request timeout to a higher value, such as
    300 seconds, to accommodate longer-running operations like module installation
    or report generation. Set the maximum number of container instances to prevent
    runaway scaling costs during unexpected traffic surges.


    ## Data Mapping and Transformation (600 words)


    ### Odoo Module and Database Schema


    Odoo employs a dynamic data model. Its core consists of fundamental models like
    `res.partner` for contacts, `product.product` for products, and `account.move`
    for accounting entries. Each installed application module extends the system by
    adding new models or fields to existing ones. This extensible architecture means
    your database schema evolves as you install new Odoo apps, such as CRM, Inventory,
    or Manufacturing.


    The system uses an object-relational mapping (ORM) layer that abstracts direct
    SQL queries. When you define a new model in a custom module, Odoo''s ORM handles
    the creation of the corresponding database table. It also manages the complex
    relationships between models, like many-to-one or many-to-many. This ORM layer
    simplifies development but requires an understanding of how Odoo structures data
    versus raw PostgreSQL tables.


    Understanding the `ir.model` and `ir.model.fields` tables is crucial. These are
    Odoo''s metadata tables that define all the models and fields in the system. They
    act as a data dictionary. When you need to perform complex data migrations or
    integrations, you often query these tables to understand the current schema structure
    programmatically, rather than assuming a fixed table layout.


    ### Filestore to Cloud Storage Mapping


    The default Odoo filestore saves files on the server''s local filesystem. It uses
    a naming convention based on the file''s SHA1 hash, splitting the hash into two
    directory levels for efficient storage. For example, a file with the hash `abc123def...`
    saves to a path like `ab/c1/abc123def...`. This structure prevents any single
    directory from containing too many files, which can cause performance issues.


    We reconfigure this mechanism to use Google Cloud Storage. The `google-cloud-storage`
    Python library provides an S3-compatible API that Odoo''s filestore system can
    utilize. We implement a custom filestore or use an existing community module that
    overrides Odoo''s core file storage methods. Instead of writing to `/path/to/filestore`,
    the system now makes API calls to store and retrieve files from the designated
    Cloud Storage bucket.


    The data mapping remains consistent; the file content and directory structure
    mirror the local filesystem approach. The key difference is the storage backend.
    This transformation is transparent to the Odoo application and its users. All
    file access operations—uploading invoices, attaching documents to records, or
    storing product images—continue to work without code changes, but the data now
    resides in a durable, scalable object store.


    ### Environment Configuration Translation


    The standard `odoo.conf` file contains key-value pairs for all system settings.
    In our Cloud Run deployment, we translate many of these settings into environment
    variables. This approach aligns with the twelve-factor app methodology and works
    better with Cloud Run''s configuration system. For instance, the `db_host` parameter
    in the config file becomes the `HOST` environment variable, and `db_password`
    becomes the `PASSWORD` variable.


    Sensitive configuration elements undergo a second transformation. We do not set
    database passwords or API keys as plaintext environment variables. Instead, we
    reference them from Google Secret Manager. Cloud Run has native integration with
    Secret Manager, allowing you to mount secrets as environment variables or volume
    files. This adds a critical security layer, ensuring credentials never appear
    in your deployment commands or service configuration UI.


    We also handle addons paths dynamically. Odoo needs to know the file system paths
    to its core addons and any custom modules. In a container, these paths are fixed.
    We set the `addons_path` parameter to include `/mnt/extra-addons` for custom modules,
    which we can populate during the Docker build stage or mount from a cloud storage
    bucket at runtime for greater flexibility in development workflows.


    ## Error Handling and Resilience (500 words)


    ### Common Deployment and Runtime Errors


    Cloud Run cold starts present a primary challenge. The first request to a new
    container instance may time out if Odoo''s initialization process takes too long.
    Odoo must preload its ORM, connect to the database, and verify all modules. This
    process can exceed Cloud Run''s default request timeout. The solution involves
    increasing the `--timeout` setting to 300s or more and optimizing your Docker
    image for faster startup by minimizing layers and removing unnecessary packages.


    Database connection errors are another frequent issue. The error "Connection to
    the database failed" often stems from incorrect Cloud SQL instance configuration.
    Verify the `--add-cloudsql-instances` flag uses the correct connection name. Ensure
    your Odoo service account has the `roles/cloudsql.client` role. Test the database
    connection from a local environment using the Cloud SQL Auth Proxy to isolate
    whether the problem is network-related or credential-based.


    File storage permissions can cause silent failures. If Odoo lacks write permissions
    to the Cloud Storage bucket, file uploads will fail without always showing a clear
    error in the Odoo log. Check the IAM permissions for the service account. It needs
    the `roles/storage.objectAdmin` role on the specific bucket. Review the Cloud
    Run logs in Google Cloud Console, as they often capture underlying permission
    denial errors from the Google Cloud client libraries.


    ### Proactive Health Monitoring


    Configure Cloud Run health checks to monitor your Odoo instance. By default, Cloud
    Run sends HTTP requests to the root URL of your service. Odoo''s web interface
    may require a login, causing these checks to fail. Create a custom health check
    endpoint. A simple controller that returns a 200 status code after verifying database
    connectivity works best. This tells Cloud Run the container is healthy and ready
    to receive traffic.


    Implement structured logging throughout your application. Odoo generates extensive
    logs, but in a containerized environment, you must write them to stdout and stderr.
    Cloud Run captures these streams and forwards them to Google Cloud Logging. Use
    consistent log formats and severity levels. This practice enables you to create
    log-based metrics and alerts for specific error patterns, such as a sudden spike
    in 5xx HTTP status codes or database connection timeouts.


    Set up alerting policies for critical errors. Google Cloud Monitoring allows you
    to define conditions that trigger alerts. Create alerts for high error rates,
    elevated latency, or container instance crashes. Configure notification channels
    like email, Slack, or PagerDuty to ensure your team responds to issues promptly.
    For business-critical operations, also monitor Odoo-specific metrics, such as
    failed transaction posts or inventory synchronization errors.


    ### Data Recovery Procedures


    Despite a managed database, you need a robust backup strategy. Cloud SQL provides
    automated backups and point-in-time recovery. Configure a backup schedule that
    aligns with your business''s data tolerance. Typically, this involves daily backups
    with a 7-day retention. For additional safety, enable point-in-time recovery,
    which lets you restore your database to any specific second within the last 7
    days, protecting against accidental data corruption or deletion.


    Prepare a documented recovery playbook. This document should outline the exact
    steps to restore your Odoo service from a backup. Test the recovery process periodically.
    A recovery drill involves creating a new Cloud SQL instance from a backup, deploying
    a new Cloud Run service pointing to this instance, and verifying data integrity.
    Regular testing ensures your team can execute a recovery under pressure without
    missing critical steps.


    Version your Docker images and database schemas. Every deployment to Cloud Run
    should use a unique image tag, not just `latest`. This practice lets you roll
    back a faulty application update by redeploying the previous known-good image
    version. Similarly, use Odoo''s module versioning and database migration scripts.
    This control over application and data state versions forms the foundation of
    a reliable, resilient deployment.


    ## Testing and Validation (500 words)


    ### Pre-Deployment Verification Checklist


    Before deploying to Cloud Run, validate your Docker image locally. Run the container
    with `docker run -p 8069:8069 -e DB_HOST=... [IMAGE_URL]` and access Odoo from
    your browser. This test confirms the image builds correctly and the application
    starts. Use the Cloud SQL Auth Proxy to simulate the database connection, ensuring
    your container can reach the Cloud SQL instance over a secure channel.


    Verify all environment variables and secrets. Create a test script that checks
    the availability of every secret in Secret Manager and validates the permissions
    of the Odoo service account. This script should attempt a dummy read from the
    Cloud Storage bucket and a test connection to the Cloud SQL database. Catching
    configuration errors in this pre-flight stage prevents deployment loops and diagnostic
    headaches after going live.


    Test the Odoo configuration in a staging environment. Deploy your Cloud Run service
    to a separate, identical project or use a different service name within the same
    project. This staging environment should mirror production exactly, including
    the database and storage bucket. Perform a full installation of Odoo, including
    all the modules you plan to use in production. This end-to-end test uncovers environment-specific
    issues before they affect users.


    ### Post-Deployment Functional Tests


    Execute a comprehensive smoke test suite immediately after deployment. This test
    should include accessing the Odoo login page, creating a new database (if in multi-tenant
    mode), and installing a core module like Sales or Contacts. Verify that basic
    CRUD operations work: create a new contact, update its details, and then delete
    it. These actions test the database connection, ORM functionality, and basic UI
    rendering.


    Validate the filestore integration thoroughly. Upload a file attachment to a record,
    such as a PDF to a sales order. Then, download the same file. Confirm the file
    stores in your Cloud Storage bucket with the correct path and permissions. Test
    with different file types and sizes to ensure the integration handles various
    scenarios. This validation is critical, as filestore issues may not manifest as
    immediate, visible errors.


    Test user access control and multi-company settings if applicable. Create test
    users with different permission groups and verify they can only access the intended
    data and menus. If you use Odoo''s multi-company features, ensure data isolation
    works correctly. These tests confirm that the underlying security and access control
    mechanisms, which rely on database rules and Odoo''s ORM, function in the Cloud
    Run environment.


    ### Load and Performance Benchmarking


    Assess the cold start performance. Time how long it takes for the first request
    to succeed after deploying a new revision or when traffic triggers a scale-from-zero
    event. This measurement sets user expectations and helps you evaluate image optimization
    efforts. If cold starts are too long, consider using minimum instances set to
    1 to keep a container always warm, though this increases cost.


    Simulate concurrent user traffic. Use a load testing tool like Apache JMeter or
    `artillery` to send multiple simultaneous requests to your Odoo instance. Monitor
    the Cloud Run metrics in the console, specifically the request count, latency,
    and container instance count. Observe how the service scales under load and where
    bottlenecks occur—whether in the Odoo application logic, the database, or the
    network.


    Establish performance baselines for key operations. Measure the response time
    for loading the dashboard, opening a list view of 1000 records, and generating
    a standard report. Run these tests periodically and compare results against your
    baseline. A significant deviation can indicate a problem with the database, a
    new inefficient module, or resource constraints on the Cloud Run service. This
    proactive monitoring maintains a quality user experience.


    ## Security Considerations (400 words)


    ### Identity and Access Management


    The principle of least privilege governs our entire setup. The Odoo service account
    possesses only the permissions essential for its operation: connecting to the
    specific Cloud SQL instance and reading/writing to the specific Storage bucket.
    It does not have broad project-level editor roles. This containment limits the
    potential impact of a compromised container. Even if an attacker gains code execution
    inside the container, their lateral movement remains restricted.


    Secure your database connections with private IP. During Cloud SQL instance creation,
    you configured a private IP address. The Cloud Run service connects to this IP
    via a VPC connector or the `--add-cloudsql-instances` flag, which uses a sidecar
    proxy. This configuration ensures all database traffic occurs within Google''s
    internal network, never exposing your database to the public internet. It eliminates
    a major attack vector.


    Manage all secrets with Google Secret Manager. Database passwords, Odoo master
    passwords, and API keys for external services all reside in Secret Manager, not
    in your Docker image or environment variables in plaintext. Cloud Run can inject
    these secrets as environment variables or mount them as files in the container''s
    filesystem. This approach provides centralized management, audit trails, and automatic
    secret rotation capabilities.


    ### Application and Network Security


    Configure Odoo with a strong master password. This password controls access to
    the database management screens in Odoo. Without it, users cannot create, duplicate,
    or drop databases. In a production environment, you typically pre-create the database,
    so set this password via Secret Manager and use it to lock down administrative
    functions. This prevents unauthorized access to Odoo''s most powerful operations.


    Enforce HTTPS for all traffic. Cloud Run provides TLS termination by default,
    automatically serving your service over a secure HTTPS connection. It also offers
    a managed SSL certificate feature for your custom domains. Redirect all HTTP traffic
    to HTTPS by setting the `X-Forwarded-Proto` header or using a separate load balancer
    configuration. Encrypted data in transit protects user sessions and sensitive
    business information.


    Implement Odoo''s built-in security features. Regularly update your Odoo image
    to incorporate the latest security patches for both Odoo itself and its underlying
    Python dependencies. Use Odoo''s access control lists (ACLs) to define user groups
    and permissions with precision. Disable any unused Odoo apps or endpoints to reduce
    the application''s attack surface. A minimal, well-configured application is a
    secure application.


    ## Performance Optimization (400 words)


    ### Cold Start Mitigation Strategies


    Cold starts represent the most significant performance challenge for serverless
    Odoo. The key is to minimize your Docker image size. Use a slim base image, like
    the official `odoo:18.0` image, but consider building from a lighter base like
    `python:slim` if you have advanced control over dependencies. Combine RUN instructions
    in your Dockerfile to reduce layers and clean up the package cache in the same
    layer that installs packages.


    Optimize the Odoo startup sequence. Odoo preloads its module registry, which can
    be slow. For production, consider using the `--load` command-line option to specify
    only the core modules needed for initial operation, deferring the loading of less
    critical modules. You can also explore using the `--workers` parameter, even in
    a Cloud Run context, to pre-fork processes, though this requires careful memory
    management.


    The most direct solution is to configure a minimum number of instances. Set the
    `--min-instances` parameter to 1 to keep at least one container instance running
    at all times. This setting eliminates cold starts for the first user but incurs
    a continuous cost. Balance this cost against your user experience requirements.
    For development instances, you might accept cold starts; for production, the cost
    of a minimum instance is often justified.


    ### Database and Cache Optimization


    Database performance dictates overall application responsiveness. On Cloud SQL,
    enable the `cloudsql.iam_authentication` flag if you use IAM-based authentication,
    which can streamline connections. Configure the `max_connections` parameter on
    your Cloud SQL instance to a value that accommodates the maximum number of concurrent
    Cloud Run container instances multiplied by the database connections each uses.


    Implement a Redis cache for Odoo sessions and frequently accessed data. Deploy
    a Google Cloud Memorystore Redis instance. Configure Odoo to use this Redis instance
    for its cache and session storage. This externalization prevents cache loss when
    Cloud Run terminates containers and allows all container instances to share a
    common cache. This is vital for user session consistency and for caching expensive
    database queries.


    Monitor and analyze slow database queries. Odoo''s ORM can sometimes generate
    inefficient SQL. Use Cloud SQL''s built-in query insights and slow query logs
    to identify problematic queries. Often, adding a specific database index on a
    frequently filtered field can improve performance by orders of magnitude. Regularly
    review the performance of key reports and list views, as these are common bottlenecks.


    ### Cost-Performance Trade-offs


    Your choice of CPU and memory allocation impacts both performance and cost. Odoo
    is a memory-intensive application. Allocating too little memory (less than 1Gi)
    will cause excessive disk swapping inside the container, leading to terrible performance.
    Start with 2Gi of memory and 1 CPU, then monitor the container''s memory usage.
    Adjust upwards if you see the service approaching its memory limit.


    Understand Cloud Run''s concurrency model. The `--concurrency` setting defines
    how many requests a single container instance can handle simultaneously. A higher
    concurrency value (e.g., 80) improves resource utilization and reduces the number
    of container instances, which can lower cost. However, setting it too high may
    increase response latency as requests queue up. Test different concurrency values
    under load to find the sweet spot for your workload.


    Use a CDN for static assets. While Odoo serves its own static files (JavaScript,
    CSS, images), this consumes container CPU cycles. For a global user base, configure
    a CDN like Google Cloud CDN to cache these static assets at edge locations. This
    reduces latency for users and offloads work from your Cloud Run service, allowing
    it to dedicate more resources to dynamic application logic.'
  conclusion: 'You now possess a production-ready Odoo 18 deployment that operates
    without manual server management. This architecture eliminates the traditional
    burdens of patching, scaling, and hardware failures. Your system scales automatically
    with user demand, ensuring performance during peak usage and minimizing costs
    during quiet periods. The separation of compute and data creates a resilient foundation
    where your business information remains safe even as application containers start
    and stop. You have built a modern ERP platform ready for growth.


    The immediate outcomes are clear and measurable. You will see a dramatic reduction
    in time spent on server maintenance and operational fire drills. Your deployment
    process is now codified and repeatable, using infrastructure-as-code principles.
    The integrated logging and monitoring provide deep visibility into application
    health and user activity. This setup transforms Odoo from a static piece of software
    into a dynamic, managed service that aligns with agile business operations.


    Look beyond the technical setup to the strategic advantages. This deployment model
    frees your technical team to focus on higher-value work, like custom module development
    and business process optimization. The inherent scalability means your Odoo instance
    can support new business units, acquisitions, or seasonal surges without a major
    infrastructure project. The use of Google''s secure and compliant infrastructure
    provides a strong foundation for meeting data governance and regulatory requirements.


    Your next step is to operationalize this deployment. Establish a CI/CD pipeline
    using Cloud Build to automate testing and deployment of new Odoo versions or custom
    modules. Implement a rigorous backup and disaster recovery drill schedule to ensure
    business continuity. Begin exploring advanced configurations, such as multi-region
    deployment for global redundancy or integrating with other Google Cloud services
    like Pub/Sub for asynchronous workflows. You have built the platform; now you
    can innovate on top of it.'
  extended_content: ''
conversion_assets:
- component_type: callout-box
  placement_hint: mid_guide
  generated_copy:
    headline: Use the Requirements Calculator
    body: Calculate exact server specs before deployment
    cta_text: Use the Requirements Calculator
    cta_link: /toolkit/odoo-requirements-calculator/
    cta_context: Priority 0.5 link from intelligent linking system
- component_type: callout-box
  placement_hint: post_technical
  generated_copy:
    headline: Use the Hosting Advisor
    body: Vendor-neutral hosting decision framework
    cta_text: Use the Hosting Advisor
    cta_link: /toolkit/odoo-hosting-advisor/
    cta_context: Priority 1 link from intelligent linking system
intelligent_links:
- link_url: /odoo-self-hosting-guide/
  anchor_text: Complete Self-Hosting Guide
  context: Comprehensive self-hosting decision framework and architecture guide
  link_type: implementation_guide
  priority: 3.5
- link_url: /odoo-minimum-requirements-deployment-guide/
  anchor_text: Deployment Requirements Guide
  context: Complete deployment requirements and sizing recommendations
  link_type: implementation_guide
  priority: 3.8
- link_url: /odoo-database-backup-restore-guide/
  anchor_text: Backup & Restore Guide
  context: Production-grade backup and disaster recovery procedures
  link_type: implementation_guide
  priority: 3.7
- link_url: /odoo-implementation-guide/
  anchor_text: Complete Implementation Guide
  context: Master implementation planning to avoid $250K+ failures
  link_type: implementation_guide
  priority: 5.5
- link_url: /guides/install-odoo-18-on-debian-12/
  anchor_text: 'Install Odoo 18 on Debian 12: Complete 2025 Guide'
  context: Secure and optimize your installation
  link_type: related_topic
  priority: 4
- link_url: /guides/install-odoo-18-on-windows-server-2022/
  anchor_text: 'Install Odoo 18 on Windows 2022: Complete 2025 Guide'
  context: Secure and optimize your installation
  link_type: related_topic
  priority: 4
- link_url: /guides/install-odoo-18-on-ubuntu-2204/
  anchor_text: 'Install Odoo 18 on Ubuntu 22.04: Complete 2025 Guide'
  context: Secure and optimize your installation
  link_type: related_topic
  priority: 4
- link_url: /guides/install-odoo-18-on-rocky-linux-9/
  anchor_text: 'Install Odoo 18 on Rocky Linux 9: Complete 2025 Guide'
  context: Secure and optimize your installation
  link_type: related_topic
  priority: 4
- link_url: /guides/install-odoo-18-on-fedora-39/
  anchor_text: 'Install Odoo 18 on Fedora 39: Complete 2025 Guide'
  context: Secure and optimize your installation
  link_type: related_topic
  priority: 4
visualizations:
- chart_type: mermaid
  placement_hint: after_steps
  data_context: installation workflow visualization (semantic variant)
  mermaid_chart_syntax: "flowchart LR\n    Start([Google Cloud Run Server]) --> Update[Update\
    \ System Packages]\n    Update --> Postgres[Install PostgreSQL 15]\n    Postgres\
    \ --> Python[Install Python 3.11]\n    Python --> Deps[Install Dependencies]\n\
    \    Deps --> Odoo[Install Odoo 18]\n    Odoo --> Config[Configure systemd Service]\n\
    \    Config --> Nginx[Setup Nginx Reverse Proxy]\n    Nginx --> SSL[Configure\
    \ SSL/TLS]\n    SSL --> End([Production Ready])\n\n    classDef step fill:#f8f9fa,stroke:#6c757d,stroke-width:1px\n\
    \    classDef database fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px\n    classDef\
    \ milestone fill:#d4edda,stroke:#28a745,stroke-width:2px\n\n    class Update,Deps,Config,Nginx,SSL\
    \ step\n    class Postgres,Python database\n    class Start,Odoo,End milestone\n"
  variant_id: install_chart_001
- chart_type: mermaid
  placement_hint: after_prerequisites
  data_context: 'Phase 1: Development Tools Setup'
  mermaid_chart_syntax: "flowchart TB\n    Start([Development Setup]) --> IDE[Install\
    \ VS Code/PyCharm]\n    IDE --> Git[Configure Git]\n    Git --> Extensions[Install\
    \ Extensions]\n    Extensions --> Debug[Setup Debugger]\n    Debug --> Linter[Configure\
    \ Linters]\n    Linter --> Format[Setup Code Formatters]\n    Format --> End([Dev\
    \ Tools Ready])\n\n    classDef tools fill:#9c27b0,stroke:#7b1fa2,stroke-width:2px,color:#fff\n\
    \    classDef config fill:#e3f2fd,stroke:#1976d2,stroke-width:1px\n    classDef\
    \ success fill:#d4edda,stroke:#28a745,stroke-width:2px\n\n    class IDE,Git,Extensions\
    \ tools\n    class Debug,Linter,Format config\n    class Start,End success\n"
  variant_id: install_chart_007_devtools
- chart_type: mermaid
  placement_hint: after_steps
  data_context: 'Phase 3: Testing & Quality Setup'
  mermaid_chart_syntax: "flowchart LR\n    Start([Quality Setup]) --> Unit[Setup Unit\
    \ Tests]\n    Unit --> Coverage[Configure Coverage.py]\n    Coverage --> Pre[Pre-commit\
    \ Hooks]\n    Pre --> CI[Local CI Pipeline]\n    CI --> Quality[Code Quality Tools]\n\
    \    Quality --> End([Testing Ready])\n\n    classDef test fill:#4caf50,stroke:#388e3c,stroke-width:2px,color:#fff\n\
    \    classDef quality fill:#ff9800,stroke:#f57c00,stroke-width:2px,color:#fff\n\
    \    classDef success fill:#d4edda,stroke:#28a745,stroke-width:2px\n\n    class\
    \ Unit,Coverage,Pre test\n    class CI,Quality quality\n    class Start,End success\n"
  variant_id: install_chart_007_testing
- chart_type: mermaid
  placement_hint: after_conclusion
  data_context: learning path and knowledge graph
  mermaid_chart_syntax: "flowchart TB\n\n    Current[\"[CURRENT] Deploy Odoo 18 on\
    \ Google Cloud Run: Complete 2025 Guide\"]\n\n    %% Next Steps - Learning Progression\n\
    \    Current --> Next0(\"Upgrade from Odoo 11 to 18\")\n    Current --> Next1(\"\
    Optimize PostgreSQL Performance: Improve Performance by 50%\")\n\n    %% Related\
    \ Topics - Cross-References\n    Current -.-> Rel0[\"Install Odoo 18 on Debian\
    \ 12: Complete 2025 Guide\"]\n    Current -.-> Rel1[\"Install Odoo 18 on Windows\
    \ 2022: Complete 2025 Guide\"]\n    Current -.-> Rel2[\"Install Odoo 18 on Ubuntu\
    \ 22.04: Complete 2025 Guide\"]\n\n    %% Professional Styling\n    classDef current\
    \ fill:#ffc107,stroke:#ff9800,stroke-width:3px,color:#000\n    classDef prereq\
    \ fill:#e3f2fd,stroke:#1976d2,stroke-width:2px,color:#000\n    classDef next fill:#e8f5e9,stroke:#388e3c,stroke-width:2px,color:#000\n\
    \    classDef related fill:#f5f5f5,stroke:#616161,stroke-width:1px,color:#000\n\
    \    classDef trouble fill:#fff3e0,stroke:#f57c00,stroke-width:2px,color:#000\n\
    \    classDef support fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#000\n\
    \n    class Current current\n    class Next0,Next1 next\n    class Rel0,Rel1,Rel2\
    \ related"
- chart_type: mermaid
  placement_hint: after_prerequisites
  data_context: 'Phase 1: Infrastructure Preparation'
  mermaid_chart_syntax: "flowchart TB\n    Start([Server Provisioning]) --> Hardware[Verify\
    \ Hardware Requirements]\n    Hardware --> Network[Configure Network Settings]\n\
    \    Network --> DNS[Setup DNS Records]\n    DNS --> Firewall[Configure Firewall\
    \ Rules]\n    Firewall --> Users[Create System Users]\n    Users --> Dirs[Setup\
    \ Directory Structure]\n    Dirs --> End([Infrastructure Ready])\n\n    classDef\
    \ prep fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    classDef network fill:#e1f5fe,stroke:#0277bd,stroke-width:1px\n\
    \    classDef success fill:#d4edda,stroke:#28a745,stroke-width:2px\n\n    class\
    \ Hardware,Users,Dirs prep\n    class Network,DNS,Firewall network\n    class\
    \ Start,End success\n"
  variant_id: install_chart_001_prep
- chart_type: mermaid
  placement_hint: after_configuration
  data_context: 'Phase 3: Security Hardening & Configuration'
  mermaid_chart_syntax: "flowchart LR\n    Start([Post-Installation]) --> SSH[Harden\
    \ SSH Config]\n    SSH --> Fail2ban[Install Fail2ban]\n    Fail2ban --> UFW[Configure\
    \ UFW/iptables]\n    UFW --> Perms[Set File Permissions]\n    Perms --> Backup[Setup\
    \ Automated Backups]\n    Backup --> Monitor[Configure Monitoring]\n    Monitor\
    \ --> End([Security Hardened])\n\n    classDef security fill:#f44336,stroke:#d32f2f,stroke-width:2px,color:#fff\n\
    \    classDef ops fill:#9c27b0,stroke:#7b1fa2,stroke-width:2px,color:#fff\n  \
    \  classDef success fill:#d4edda,stroke:#28a745,stroke-width:2px\n\n    class\
    \ SSH,Fail2ban,UFW,Perms security\n    class Backup,Monitor ops\n    class Start,End\
    \ success\n"
  variant_id: install_chart_001_security
- chart_type: mermaid
  placement_hint: before_troubleshooting
  data_context: 'Phase 4: Testing & Validation'
  mermaid_chart_syntax: "flowchart LR\n    Start([Deployment Complete]) --> Health[Health\
    \ Check API]\n    Health --> Database[Database Connectivity Test]\n    Database\
    \ --> Login[Admin Login Test]\n    Login --> Module[Module Installation Test]\n\
    \    Module --> Load[Basic Load Test]\n    Load --> SSL[SSL Certificate Validation]\n\
    \    SSL --> End([Validated & Production Ready])\n\n    classDef test fill:#e3f2fd,stroke:#1976d2,stroke-width:2px\n\
    \    classDef critical fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    classDef\
    \ success fill:#d4edda,stroke:#28a745,stroke-width:2px\n\n    class Health,Database,Login,Module,Load\
    \ test\n    class SSL critical\n    class Start,End success\n"
  variant_id: install_chart_001_testing
