# Odoo API Development Patterns and Best Practices
# Last Verified: 2025-10-29
# Data Sources: Odoo documentation, API design guidelines, REST/JSON-RPC specifications

api_overview:
  description: "Comprehensive patterns for developing and integrating with Odoo APIs"
  api_types:
    - xml_rpc: "Legacy protocol, widely supported"
    - json_rpc: "Modern protocol, recommended for new integrations"
    - rest_api: "Custom REST endpoints using controllers"
    - graphql: "Query language for flexible data fetching"
    - websocket: "Real-time bidirectional communication"

  authentication_methods:
    - api_keys: "Token-based authentication"
    - oauth2: "Standard authorization framework"
    - session: "Cookie-based session management"
    - basic_auth: "Username/password in headers"

json_rpc_patterns:
  connection_setup:
    python_example: |
      import requests
      import json

      class OdooAPI:
          def __init__(self, url, db, username, password):
              self.url = url
              self.db = db
              self.username = username
              self.password = password
              self.uid = None
              self.session = requests.Session()

          def authenticate(self):
              """Authenticate and get user id"""
              endpoint = f"{self.url}/web/session/authenticate"
              params = {
                  "jsonrpc": "2.0",
                  "method": "call",
                  "params": {
                      "db": self.db,
                      "login": self.username,
                      "password": self.password
                  },
                  "id": 1
              }

              response = self.session.post(
                  endpoint,
                  json=params,
                  headers={'Content-Type': 'application/json'}
              )

              result = response.json()
              if result.get('result'):
                  self.uid = result['result']['uid']
                  return True
              return False

    javascript_example: |
      class OdooAPI {
          constructor(url, db, username, password) {
              this.url = url;
              this.db = db;
              this.username = username;
              this.password = password;
              this.session_id = null;
          }

          async authenticate() {
              const response = await fetch(`${this.url}/web/session/authenticate`, {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                      jsonrpc: '2.0',
                      method: 'call',
                      params: {
                          db: this.db,
                          login: this.username,
                          password: this.password
                      },
                      id: 1
                  })
              });

              const data = await response.json();
              if (data.result) {
                  this.session_id = data.result.session_id;
                  return true;
              }
              return false;
          }
      }

  crud_operations:
    create_record: |
      def create_record(self, model, values):
          """Create a new record"""
          endpoint = f"{self.url}/web/dataset/call_kw"
          params = {
              "jsonrpc": "2.0",
              "method": "call",
              "params": {
                  "model": model,
                  "method": "create",
                  "args": [values],
                  "kwargs": {}
              },
              "id": 2
          }
          response = self.session.post(endpoint, json=params)
          return response.json()['result']

    read_records: |
      def search_read(self, model, domain=None, fields=None, limit=100, offset=0):
          """Search and read records in one call"""
          endpoint = f"{self.url}/web/dataset/call_kw"
          params = {
              "jsonrpc": "2.0",
              "method": "call",
              "params": {
                  "model": model,
                  "method": "search_read",
                  "args": [],
                  "kwargs": {
                      "domain": domain or [],
                      "fields": fields or [],
                      "limit": limit,
                      "offset": offset
                  }
              },
              "id": 3
          }
          response = self.session.post(endpoint, json=params)
          return response.json()['result']

    update_record: |
      def update_record(self, model, record_id, values):
          """Update existing record"""
          endpoint = f"{self.url}/web/dataset/call_kw"
          params = {
              "jsonrpc": "2.0",
              "method": "call",
              "params": {
                  "model": model,
                  "method": "write",
                  "args": [[record_id], values],
                  "kwargs": {}
              },
              "id": 4
          }
          response = self.session.post(endpoint, json=params)
          return response.json()['result']

    delete_record: |
      def delete_record(self, model, record_id):
          """Delete a record"""
          endpoint = f"{self.url}/web/dataset/call_kw"
          params = {
              "jsonrpc": "2.0",
              "method": "call",
              "params": {
                  "model": model,
                  "method": "unlink",
                  "args": [[record_id]],
                  "kwargs": {}
              },
              "id": 5
          }
          response = self.session.post(endpoint, json=params)
          return response.json()['result']

  advanced_queries:
    complex_domain: |
      # Complex search with AND/OR conditions
      domain = [
          '|',  # OR operator
          ['state', '=', 'draft'],
          '&',  # AND operator
          ['amount_total', '>', 1000],
          ['partner_id.country_id.code', '=', 'US']
      ]

      results = api.search_read('sale.order', domain=domain)

    grouped_data: |
      def read_group(self, model, domain, fields, groupby):
          """Get grouped/aggregated data"""
          endpoint = f"{self.url}/web/dataset/call_kw"
          params = {
              "jsonrpc": "2.0",
              "method": "call",
              "params": {
                  "model": model,
                  "method": "read_group",
                  "args": [],
                  "kwargs": {
                      "domain": domain,
                      "fields": fields,
                      "groupby": groupby
                  }
              },
              "id": 6
          }
          response = self.session.post(endpoint, json=params)
          return response.json()['result']

      # Example: Sales by partner
      grouped = api.read_group(
          'sale.order',
          [],
          ['partner_id', 'amount_total:sum'],
          ['partner_id']
      )

rest_api_patterns:
  controller_definition:
    basic_controller: |
      from odoo import http
      from odoo.http import request
      import json

      class MyAPI(http.Controller):

          @http.route('/api/v1/ping', type='json', auth='none', cors='*')
          def ping(self):
              """Health check endpoint"""
              return {'status': 'ok', 'message': 'pong'}

          @http.route('/api/v1/authenticate', type='json', auth='none', cors='*')
          def authenticate(self, db, login, password):
              """Authenticate user and return token"""
              request.session.authenticate(db, login, password)
              return {
                  'uid': request.session.uid,
                  'session_id': request.session.sid,
                  'partner_id': request.env.user.partner_id.id
              }

    crud_endpoints: |
      class ProductAPI(http.Controller):

          @http.route('/api/v1/products', type='json', auth='user', methods=['GET'])
          def get_products(self, limit=10, offset=0, **kwargs):
              """Get product list"""
              products = request.env['product.product'].search_read(
                  [],
                  ['name', 'default_code', 'list_price', 'qty_available'],
                  limit=limit,
                  offset=offset
              )
              return {'products': products, 'count': len(products)}

          @http.route('/api/v1/products/<int:product_id>', type='json', auth='user', methods=['GET'])
          def get_product(self, product_id):
              """Get single product"""
              product = request.env['product.product'].browse(product_id)
              if not product.exists():
                  return {'error': 'Product not found'}, 404

              return {
                  'id': product.id,
                  'name': product.name,
                  'default_code': product.default_code,
                  'list_price': product.list_price,
                  'qty_available': product.qty_available
              }

          @http.route('/api/v1/products', type='json', auth='user', methods=['POST'])
          def create_product(self, **kwargs):
              """Create new product"""
              required_fields = ['name', 'list_price']
              for field in required_fields:
                  if field not in kwargs:
                      return {'error': f'Missing required field: {field}'}, 400

              product = request.env['product.product'].create({
                  'name': kwargs.get('name'),
                  'default_code': kwargs.get('default_code'),
                  'list_price': kwargs.get('list_price'),
                  'standard_price': kwargs.get('standard_price', 0)
              })

              return {'id': product.id, 'message': 'Product created successfully'}

          @http.route('/api/v1/products/<int:product_id>', type='json', auth='user', methods=['PUT'])
          def update_product(self, product_id, **kwargs):
              """Update product"""
              product = request.env['product.product'].browse(product_id)
              if not product.exists():
                  return {'error': 'Product not found'}, 404

              update_vals = {}
              allowed_fields = ['name', 'default_code', 'list_price', 'standard_price']
              for field in allowed_fields:
                  if field in kwargs:
                      update_vals[field] = kwargs[field]

              product.write(update_vals)
              return {'message': 'Product updated successfully'}

          @http.route('/api/v1/products/<int:product_id>', type='json', auth='user', methods=['DELETE'])
          def delete_product(self, product_id):
              """Delete product"""
              product = request.env['product.product'].browse(product_id)
              if not product.exists():
                  return {'error': 'Product not found'}, 404

              product.unlink()
              return {'message': 'Product deleted successfully'}

  authentication_patterns:
    api_key_auth: |
      class APIKeyAuth(http.Controller):

          def _check_api_key(self, api_key):
              """Validate API key"""
              user = request.env['res.users'].sudo().search([
                  ('api_key', '=', api_key),
                  ('api_key_expiry', '>', fields.Datetime.now())
              ], limit=1)

              if user:
                  request.uid = user.id
                  return user
              return False

          @http.route('/api/v1/protected', type='json', auth='none')
          def protected_endpoint(self, api_key, **kwargs):
              """Protected endpoint requiring API key"""
              user = self._check_api_key(api_key)
              if not user:
                  return {'error': 'Invalid or expired API key'}, 401

              # Process request with authenticated user
              request.env = request.env(user=user)
              return {'data': 'Protected data'}

    oauth2_implementation: |
      class OAuth2Provider(http.Controller):

          @http.route('/oauth/authorize', type='http', auth='user', website=True)
          def authorize(self, client_id, redirect_uri, response_type='code', **kwargs):
              """OAuth2 authorization endpoint"""
              # Validate client_id and redirect_uri
              client = request.env['oauth.client'].search([
                  ('client_id', '=', client_id),
                  ('redirect_uri', '=', redirect_uri)
              ])

              if not client:
                  return request.render('oauth.error', {'error': 'Invalid client'})

              # Generate authorization code
              code = request.env['oauth.code'].create({
                  'client_id': client.id,
                  'user_id': request.env.user.id,
                  'code': uuid.uuid4().hex
              })

              return werkzeug.utils.redirect(f"{redirect_uri}?code={code.code}")

          @http.route('/oauth/token', type='json', auth='none', csrf=False)
          def token(self, grant_type, code=None, refresh_token=None, **kwargs):
              """OAuth2 token endpoint"""
              if grant_type == 'authorization_code':
                  # Exchange code for token
                  auth_code = request.env['oauth.code'].sudo().search([
                      ('code', '=', code),
                      ('used', '=', False)
                  ])

                  if not auth_code:
                      return {'error': 'Invalid authorization code'}, 400

                  # Create access token
                  token = request.env['oauth.token'].sudo().create({
                      'user_id': auth_code.user_id.id,
                      'client_id': auth_code.client_id.id,
                      'access_token': uuid.uuid4().hex,
                      'refresh_token': uuid.uuid4().hex,
                      'expires_in': 3600
                  })

                  auth_code.used = True

                  return {
                      'access_token': token.access_token,
                      'refresh_token': token.refresh_token,
                      'token_type': 'Bearer',
                      'expires_in': 3600
                  }

error_handling:
  standard_responses:
    success_response: |
      {
          "success": true,
          "data": {...},
          "message": "Operation successful"
      }

    error_response: |
      {
          "success": false,
          "error": {
              "code": "VALIDATION_ERROR",
              "message": "Invalid input data",
              "details": {
                  "field": "email",
                  "issue": "Invalid email format"
              }
          }
      }

  error_handler_decorator: |
    from functools import wraps
    import traceback

    def api_error_handler(func):
        """Decorator for consistent error handling"""
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except ValidationError as e:
                return {
                    'success': False,
                    'error': {
                        'code': 'VALIDATION_ERROR',
                        'message': str(e)
                    }
                }, 400
            except AccessError as e:
                return {
                    'success': False,
                    'error': {
                        'code': 'ACCESS_DENIED',
                        'message': 'Insufficient permissions'
                    }
                }, 403
            except MissingError as e:
                return {
                    'success': False,
                    'error': {
                        'code': 'NOT_FOUND',
                        'message': 'Resource not found'
                    }
                }, 404
            except Exception as e:
                _logger.error(f"API Error: {traceback.format_exc()}")
                return {
                    'success': False,
                    'error': {
                        'code': 'INTERNAL_ERROR',
                        'message': 'An unexpected error occurred'
                    }
                }, 500
        return wrapper

pagination_patterns:
  offset_pagination: |
    @http.route('/api/v1/orders', type='json', auth='user')
    def get_orders(self, limit=20, offset=0, **kwargs):
        """Get paginated orders"""
        orders = request.env['sale.order'].search_read(
            [],
            ['name', 'date_order', 'partner_id', 'amount_total'],
            limit=limit,
            offset=offset
        )

        total_count = request.env['sale.order'].search_count([])

        return {
            'data': orders,
            'pagination': {
                'limit': limit,
                'offset': offset,
                'total': total_count,
                'has_next': offset + limit < total_count,
                'has_prev': offset > 0
            }
        }

  cursor_pagination: |
    @http.route('/api/v1/orders/cursor', type='json', auth='user')
    def get_orders_cursor(self, cursor=None, limit=20, **kwargs):
        """Cursor-based pagination for better performance"""
        domain = []
        if cursor:
            domain = [('id', '>', int(cursor))]

        orders = request.env['sale.order'].search_read(
            domain,
            ['id', 'name', 'date_order', 'amount_total'],
            limit=limit + 1,
            order='id asc'
        )

        has_next = len(orders) > limit
        if has_next:
            orders = orders[:-1]

        next_cursor = orders[-1]['id'] if orders else None

        return {
            'data': orders,
            'pagination': {
                'next_cursor': next_cursor if has_next else None,
                'has_next': has_next
            }
        }

filtering_sorting:
  dynamic_filtering: |
    @http.route('/api/v1/partners/search', type='json', auth='user')
    def search_partners(self, filters=None, sort=None, **kwargs):
        """Advanced filtering and sorting"""
        domain = []

        # Build domain from filters
        if filters:
            for field, operator, value in filters:
                if operator in ['=', '!=', '>', '<', '>=', '<=', 'like', 'ilike', 'in']:
                    domain.append([field, operator, value])

        # Parse sort parameter
        order = 'id desc'  # default
        if sort:
            sort_field = sort.lstrip('-')
            sort_order = 'desc' if sort.startswith('-') else 'asc'
            order = f"{sort_field} {sort_order}"

        partners = request.env['res.partner'].search_read(
            domain,
            ['name', 'email', 'phone', 'city'],
            order=order
        )

        return {'data': partners, 'count': len(partners)}

  field_selection: |
    @http.route('/api/v1/products/flexible', type='json', auth='user')
    def get_products_flexible(self, fields=None, include=None, exclude=None, **kwargs):
        """Flexible field selection"""
        # Default fields
        default_fields = ['id', 'name', 'list_price']

        # Determine which fields to return
        if fields:
            return_fields = fields
        else:
            return_fields = default_fields

        # Add included fields
        if include:
            return_fields.extend(include)

        # Remove excluded fields
        if exclude:
            return_fields = [f for f in return_fields if f not in exclude]

        products = request.env['product.product'].search_read(
            [],
            return_fields
        )

        return {'data': products}

batch_operations:
  batch_create: |
    @http.route('/api/v1/batch/create', type='json', auth='user')
    def batch_create(self, model, records, **kwargs):
        """Create multiple records in one request"""
        created_ids = []
        errors = []

        for idx, record_data in enumerate(records):
            try:
                record = request.env[model].create(record_data)
                created_ids.append(record.id)
            except Exception as e:
                errors.append({
                    'index': idx,
                    'error': str(e)
                })

        return {
            'created_ids': created_ids,
            'errors': errors,
            'success_count': len(created_ids),
            'error_count': len(errors)
        }

  batch_update: |
    @http.route('/api/v1/batch/update', type='json', auth='user')
    def batch_update(self, model, updates, **kwargs):
        """Update multiple records"""
        results = []

        for update in updates:
            record_id = update.pop('id')
            try:
                record = request.env[model].browse(record_id)
                record.write(update)
                results.append({'id': record_id, 'success': True})
            except Exception as e:
                results.append({'id': record_id, 'success': False, 'error': str(e)})

        return {'results': results}

webhooks:
  webhook_implementation: |
    class WebhookMixin(models.AbstractModel):
        _name = 'webhook.mixin'

        def trigger_webhook(self, event_type, data):
            """Trigger webhooks for an event"""
            webhooks = self.env['webhook.config'].search([
                ('model', '=', self._name),
                ('event', '=', event_type),
                ('active', '=', True)
            ])

            for webhook in webhooks:
                self._send_webhook(webhook, data)

        def _send_webhook(self, webhook, data):
            """Send webhook request"""
            payload = {
                'event': webhook.event,
                'model': webhook.model,
                'timestamp': fields.Datetime.now().isoformat(),
                'data': data
            }

            # Add signature for security
            signature = hmac.new(
                webhook.secret.encode(),
                json.dumps(payload).encode(),
                hashlib.sha256
            ).hexdigest()

            headers = {
                'Content-Type': 'application/json',
                'X-Odoo-Signature': signature
            }

            try:
                response = requests.post(
                    webhook.url,
                    json=payload,
                    headers=headers,
                    timeout=10
                )
                webhook.last_response = response.status_code
            except Exception as e:
                _logger.error(f"Webhook failed: {e}")

rate_limiting:
  implementation: |
    import time
    from collections import defaultdict
    from datetime import datetime, timedelta

    class RateLimiter:
        def __init__(self):
            self.requests = defaultdict(list)

        def is_allowed(self, key, max_requests=100, window=3600):
            """Check if request is allowed under rate limit"""
            now = time.time()
            min_time = now - window

            # Clean old requests
            self.requests[key] = [
                req_time for req_time in self.requests[key]
                if req_time > min_time
            ]

            # Check limit
            if len(self.requests[key]) >= max_requests:
                return False

            # Add current request
            self.requests[key].append(now)
            return True

    rate_limiter = RateLimiter()

    @http.route('/api/v1/limited', type='json', auth='user')
    def limited_endpoint(self, **kwargs):
        """Rate limited endpoint"""
        user_key = f"user_{request.env.user.id}"

        if not rate_limiter.is_allowed(user_key, max_requests=100, window=3600):
            return {
                'error': 'Rate limit exceeded',
                'retry_after': 60
            }, 429

        # Process request
        return {'data': 'Success'}

caching_strategies:
  redis_cache: |
    import redis
    import pickle
    import hashlib

    redis_client = redis.StrictRedis(host='localhost', port=6379, db=0)

    def cache_key(prefix, *args, **kwargs):
        """Generate cache key from arguments"""
        key_data = f"{prefix}:{args}:{sorted(kwargs.items())}"
        return hashlib.md5(key_data.encode()).hexdigest()

    def cached_api(ttl=300):
        """Decorator for API response caching"""
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                # Generate cache key
                key = cache_key(func.__name__, *args, **kwargs)

                # Try to get from cache
                cached = redis_client.get(key)
                if cached:
                    return pickle.loads(cached)

                # Call function and cache result
                result = func(*args, **kwargs)
                redis_client.setex(
                    key,
                    ttl,
                    pickle.dumps(result)
                )

                return result
            return wrapper
        return decorator

    @http.route('/api/v1/cached/products', type='json', auth='user')
    @cached_api(ttl=600)
    def get_cached_products(self, category_id=None):
        """Cached product endpoint"""
        domain = [('category_id', '=', category_id)] if category_id else []
        return request.env['product.product'].search_read(domain)

api_versioning:
  url_versioning: |
    # Version in URL path
    @http.route('/api/v1/products', type='json', auth='user')
    def products_v1(self):
        return {'version': 1, 'data': [...]}

    @http.route('/api/v2/products', type='json', auth='user')
    def products_v2(self):
        return {'version': 2, 'data': [...], 'meta': {...}}

  header_versioning: |
    @http.route('/api/products', type='json', auth='user')
    def products(self, **kwargs):
        """Version via header"""
        version = request.httprequest.headers.get('API-Version', '1')

        if version == '1':
            return self._products_v1()
        elif version == '2':
            return self._products_v2()
        else:
            return {'error': 'Unsupported API version'}, 400

testing_patterns:
  unit_tests: |
    from odoo.tests.common import TransactionCase
    import json

    class TestAPI(TransactionCase):

        def setUp(self):
            super().setUp()
            self.api = OdooAPI(
                'http://localhost:8069',
                'test_db',
                'admin',
                'admin'
            )

        def test_authentication(self):
            """Test API authentication"""
            result = self.api.authenticate()
            self.assertTrue(result)
            self.assertIsNotNone(self.api.uid)

        def test_create_partner(self):
            """Test partner creation via API"""
            partner_data = {
                'name': 'Test Partner',
                'email': 'test@example.com'
            }
            partner_id = self.api.create_record('res.partner', partner_data)
            self.assertIsNotNone(partner_id)

            # Verify creation
            partner = self.env['res.partner'].browse(partner_id)
            self.assertEqual(partner.name, 'Test Partner')

  integration_tests: |
    import requests
    import unittest

    class TestAPIIntegration(unittest.TestCase):

        @classmethod
        def setUpClass(cls):
            cls.base_url = 'http://localhost:8069/api/v1'
            cls.session = requests.Session()

            # Authenticate
            auth_response = cls.session.post(
                f'{cls.base_url}/authenticate',
                json={
                    'db': 'test_db',
                    'login': 'admin',
                    'password': 'admin'
                }
            )
            cls.session_id = auth_response.json()['session_id']

        def test_product_crud(self):
            """Test complete CRUD cycle"""
            # Create
            create_response = self.session.post(
                f'{self.base_url}/products',
                json={
                    'name': 'Test Product',
                    'list_price': 100.0
                }
            )
            self.assertEqual(create_response.status_code, 200)
            product_id = create_response.json()['id']

            # Read
            read_response = self.session.get(
                f'{self.base_url}/products/{product_id}'
            )
            self.assertEqual(read_response.status_code, 200)
            self.assertEqual(read_response.json()['name'], 'Test Product')

            # Update
            update_response = self.session.put(
                f'{self.base_url}/products/{product_id}',
                json={'list_price': 150.0}
            )
            self.assertEqual(update_response.status_code, 200)

            # Delete
            delete_response = self.session.delete(
                f'{self.base_url}/products/{product_id}'
            )
            self.assertEqual(delete_response.status_code, 200)

best_practices:
  - "Always use HTTPS in production"
  - "Implement proper authentication and authorization"
  - "Version your APIs from the start"
  - "Use consistent error response format"
  - "Document APIs with OpenAPI/Swagger"
  - "Implement rate limiting"
  - "Log all API requests for audit"
  - "Use pagination for large datasets"
  - "Cache responses when appropriate"
  - "Validate input data thoroughly"
  - "Handle errors gracefully"
  - "Use meaningful HTTP status codes"
  - "Implement request/response compression"
  - "Monitor API performance and usage"
  - "Provide clear deprecation notices"