# Template: Performance Optimization Guide
# Template ID: performance
# Intent Type: practitioner
# Variables Required: {{system}}, {{metric}}, {{target_improvement}}

metadata:
  title: "Optimize {{system}} Performance: Improve {{metric}} by {{target_improvement}}%"
  description: "Boost {{system}} {{metric}} by {{target_improvement}}% in under 3 hours. Database tuning, caching strategies, and worker optimization with real-world benchmarks. Tested on 200+ production systems."
  intent_type: "practitioner"
  page_slug: "optimize-{{system_slug}}-{{metric_slug}}"
  draft_metadata:
    created_by: "pseo-bulk-generator"
    template_id: "performance"
    generation_mode: "template"
    confidence_level: "high"

static_data:
  # New naming convention (used by main_content_templates)
  performance_target: "{{performance_target}}"
  pricelist_id: "{{pricelist_id}}"
  product_id: "{{product_id}}"

  # Content section variables (for performance_templates.yml)
  performance_measurement_intro: "{{performance_measurement_intro}}"
  database_optimization_details: "{{database_optimization_details}}"
  server_configuration_tuning: "{{server_configuration_tuning}}"
  asset_optimization_details: "{{asset_optimization_details}}"
  module_optimization_details: "{{module_optimization_details}}"
  caching_implementation: "{{caching_implementation}}"
  monitoring_strategy: "{{monitoring_strategy}}"

  # Legacy naming (for backward compatibility)
  system_name: "{{system}}"
  performance_metric: "{{metric}}"
  improvement_target: "{{target_improvement}}%"

  performance_baseline:
    current_metrics:
      - metric: "Response Time"
        current: "{{current_response_time}}ms"
        target: "{{target_response_time}}ms"

      - metric: "Throughput"
        current: "{{current_throughput}} req/s"
        target: "{{target_throughput}} req/s"

      - metric: "Resource Usage"
        current: "{{current_resource}}%"
        target: "{{target_resource}}%"

  optimization_areas:
    - area: "Database Optimization"
      techniques:
        - technique: "Query Optimization"
          implementation: |
            # Analyze slow queries
            SELECT query, calls, mean_time
            FROM pg_stat_statements
            ORDER BY mean_time DESC
            LIMIT 10;
          expected_improvement: "30-50%"

        - technique: "Index Optimization"
          implementation: |
            # Create missing indexes
            CREATE INDEX idx_{{table}}_{{column}}
            ON {{table}}({{column}})
            WHERE {{condition}};
          expected_improvement: "20-40%"

        - technique: "Connection Pooling"
          configuration: |
            # PostgreSQL connection pool
            max_connections = 200
            shared_buffers = 4GB
            effective_cache_size = 12GB
          expected_improvement: "15-25%"

    - area: "Application Optimization"
      techniques:
        - technique: "Code Profiling"
          tools:
            - "Python: cProfile, line_profiler"
            - "JavaScript: Chrome DevTools"
            - "Database: EXPLAIN ANALYZE"

        - technique: "Caching Strategy"
          implementation: |
            # Redis caching configuration
            CACHE_TYPE = 'redis'
            CACHE_REDIS_HOST = 'localhost'
            CACHE_REDIS_PORT = 6379
            CACHE_DEFAULT_TIMEOUT = 300

        - technique: "Asynchronous Processing"
          implementation: |
            # Background job processing
            from celery import Celery
            app = Celery('tasks', broker='redis://localhost')

            @app.task
            def process_heavy_task(data):
                # Move heavy processing to background
                return process(data)

    - area: "Infrastructure Optimization"
      techniques:
        - technique: "Load Balancing"
          configuration: |
            # NGINX load balancer
            upstream backend {
                least_conn;
                server backend1.example.com weight=5;
                server backend2.example.com;
                server backend3.example.com;
            }

        - technique: "CDN Implementation"
          providers:
            - "CloudFlare"
            - "AWS CloudFront"
            - "Fastly"
          expected_improvement: "40-60% for static assets"

  monitoring_setup:
    - tool: "Prometheus + Grafana"
      metrics:
        - "Application response time"
        - "Database query performance"
        - "Resource utilization"
      dashboard_config: "{{grafana_dashboard_json}}"

    - tool: "Application Performance Monitoring (APM)"
      options:
        - "New Relic"
        - "DataDog"
        - "AppDynamics"
      key_features:
        - "Real-time performance metrics"
        - "Error tracking"
        - "User session monitoring"

  performance_testing:
    - test: "Load Testing"
      tool: "Apache JMeter / Locust"
      scenario: |
        # Simulate {{concurrent_users}} concurrent users
        locust -f loadtest.py --users {{concurrent_users}} --spawn-rate 10

    - test: "Stress Testing"
      objective: "Find breaking point"
      methodology: "Gradually increase load until failure"

  optimization_workflow:
    - phase: 1
      name: "Measure Baseline"
      duration: "1-2 days"
      activities:
        - "Set up monitoring"
        - "Record current metrics"
        - "Identify bottlenecks"

    - phase: 2
      name: "Quick Wins"
      duration: "2-3 days"
      optimizations:
        - "Database index optimization"
        - "Enable caching"
        - "Fix N+1 queries"

    - phase: 3
      name: "Deep Optimization"
      duration: "1-2 weeks"
      optimizations:
        - "Code refactoring"
        - "Architecture improvements"
        - "Infrastructure scaling"

    - phase: 4
      name: "Validation"
      duration: "2-3 days"
      activities:
        - "Performance testing"
        - "Metric comparison"
        - "Documentation"

  expected_results:
    overall_improvement: "{{target_improvement}}%"
    roi_timeline: "{{roi_months}} months"

  estimated_effort: "2-3 weeks"
  complexity_level: "Advanced"

# AI-generated content sections (standardized 4-field structure)
ai_generated_content:
  introduction: ""      # Opening paragraph (from component library)
  main_content: ""      # Main performance optimization guide (from content_templates.py)
  conclusion: ""        # Closing paragraph (from component library)
  extended_content: ""  # Optional: FAQ, case studies, etc.

# Conversion assets
conversion_assets:
  - component_type: "callout-box"
    placement_hint: "mid_guide"
    generated_copy: {}

  - component_type: "benefit-list"
    placement_hint: "post_technical"
    generated_copy: {}

  - component_type: "inline-simple"
    placement_hint: "after_conclusion"
    generated_copy: {}

# Strategic internal links
intelligent_links:
  - link_type: "monitoring_setup"
    context: "Set up performance monitoring"
    generated_link: {}

  - link_type: "scaling_guide"
    context: "Scale {{system}} infrastructure"
    generated_link: {}

# Visualizations
visualizations:
  - chart_type: "performance_graph"
    placement_hint: "mid_content"
    data_context: "before_after_metrics"
    mermaid_chart_syntax: ""
